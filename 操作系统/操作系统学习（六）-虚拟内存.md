## 操作系统之虚拟内存

### L24 内存换入-请求调页与内存换入

- `Swap in` / `Swap out`
- 让用户使用，使用分段，为了提高效率，引入分页；然后链接分段分页使用虚拟内存
![](http://i.imgur.com/BEd6eVA.png)

- 用换入，换出实现`大内存`
- 把要使用的部分换入到物理内存，建立映射
![](http://i.imgur.com/ZsQlqqK.png)
- 请求，换入（调入页面），建立映射（页面映射）
- 请求调页
- MMC查找缺页，就需要调页，即缺页中断。
- 访问的内存地址没有在内存中（没有映射），就需要在磁盘中找到地址调入内存，从而实现虚拟内存
![](http://i.imgur.com/Cr9VCrP.png)

- 一个实际系统的请求调页
![](http://i.imgur.com/kRcz8ng.png)

- `CR0,2,3`等CPU的寄存器
- 申请空闲页面，读磁盘，建立映射（放入页表）
![](http://i.imgur.com/uLJ8wiB.png)
- 修改页表

### L25 内存换出

- `Swap out`
- 选择一页淘汰，换出到磁盘，选择哪一页，就是页面置换算法
![](http://i.imgur.com/87c3NYz.png)
- FIFO页面置换
![](http://i.imgur.com/8gvzdwU.png)

- MIN页面置换
- 最远将使用的页淘汰
![](http://i.imgur.com/IEHC9nU.png)

- LRU页面置换`least recent use`
- 最近最少使用的页面淘汰
![](http://i.imgur.com/pSXGlmP.png)

- 客观世界：局部性，稀疏性，低秩性
- LRU置换算法实现
- 很巧妙的利用时间戳，缺页利用时间戳最小的值换出
- 实际操作系统实现很困难，每执行一条指令，进行地址重定位，需要查看当前页面的时间戳，效率很低，然后还要考虑时间戳溢出
![](http://i.imgur.com/pd54hYu.png)

- LRU准确实现，用页码栈
- 栈顶始终是最近访问的页面
![](http://i.imgur.com/QfT3GGB.png)

- 实际代价太多，LRU近似实现
- 将时间计数变为是和否
- 循环一圈，不是之前的最近最少访问，近似成：**最近没有访问**，转一圈如果没有改变值，即是该值最近没有被访问过
- 二次机会算法，Clock算法
![](http://i.imgur.com/dvIEGfk.png)

- 缺页少，从1置为0就少
- R置为1即页面调入，R置为0即页面将调出
- 定时清除R位，最近一段时间又没有使用，所以就清除
![](http://i.imgur.com/BCyH0eX.png) 

- 还需要解决一个问题
![](http://i.imgur.com/MKZEKOa.png)

- 理解：页面换入换出==>实现虚拟内存==>为了实现段页机制==>为了实现程序执行起来==>最终位进程
- 一个进程分为很多段，形成很多页面，但是页框可能不足够，此时产生缺页中断，进行页面调入调出
- 当访问内存时，页面不存在，产生缺少中断，然后从磁盘中调入到页面到物理内存，此时可能叶框满，需要根据clock算法将页面写入到磁盘，然后再将调入的页面写入到内存中
- `swap`分区管理
![](http://i.imgur.com/kDIt0us.png)