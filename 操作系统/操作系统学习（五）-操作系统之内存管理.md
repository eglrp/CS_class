## 操作系统之内存管理

### L20 内存使用和分段

- `Memory and Segmentation`
- 内存使用：将程序放到内存中，PC指向开始地址
- 重定位：修改程序中的地址（是相对地址）-即逻辑地址
- 什么时候完成重定位？（编译时，程序只能放在内存固定的位置；载入时，一旦载入就不能动，灵活，慢一些）
- 但是程序载入后乃需要移动
![](http://i.imgur.com/oDjuFsG.png)

- 运行是重定位
- 执行指令都要从逻辑地址算出物理地址：地址翻译
- 基地址放在PCB中
![](http://i.imgur.com/XIkOCJu.png)

- 程序分段
![](http://i.imgur.com/wwHKh0j.png)
 
- PCB要放每段的基址
![](http://i.imgur.com/IFUfEiF.png)

- GDT表是操作系统的段表，LDT每个进程的段表

### L21内存分区与分页

- `Memory Partition and paging`
- 编译时，将代码分段，然后在内存中找到空闲的分区，将数据从磁盘读入到内存中（设备驱动）
- 内存怎么分割？
- 1.固定分区（需求不一）
- 2.可变分区

- 分页：解决内存分区导致的内存效率问题
![](http://i.imgur.com/ECu67He.png)
- 将请求内存打散--->引出物理内存分页

- 页表地址表示
- MMU内存管理单元，地址%页表大小（4K）=>左移12位，商为页码，余数为页内偏移
- 逻辑地址和物理地址
- 一个程序多个段组成，每个段打散成多个页，分配到内存中的多个页中
![](http://i.imgur.com/vWC4GzP.png)

### 多级页表和快表

- `Multilevel Paging`
- 页表机制实际有问题，引出多级页表
- 为了提高内存空间利用率，页应该小，但是页小了页表就大了
- 页表大了，页表放置就成问题了
- 这里的页号和地址位数有关（逻辑地址），页框号和物理内存有关；大部分的页号（逻辑地址）不会用到
- 无效的页号（部分逻辑页号没有使用）
![](http://i.imgur.com/78A5KUm.png)

- 只存放用到的页
- 每执行一次指令，都需要查询页表一次，这样指令执行的速度就变慢了
- 这样必须页号连续才行，
![](http://i.imgur.com/IcXvvN4.png)
- 多级页表
- 32位地址，逻辑地址分成3部分。
- 内存中页表变得很小
![](http://i.imgur.com/anUwW88.png)
- 访问12MH的内存空间，但是只需要16K的内存空间
- 访问时间变长，尤其是64位系统
![](http://i.imgur.com/tLhkxck.png)

- 块表（TLB）一组相联快速存储
- 块表+多级页表==>保证了空间利用和时间的折中
![](http://i.imgur.com/VANYJlE.png)
- TLB越大，越好，但是成本越高，一般[64,1000].
- 程序的地址访问存在局部性，空间局部性，程序多体现为循环，顺序结构

### L23 段页结合的实际内存管理

- `Segmentation and Paging`
- 虚拟内存 / 地址空间 将段页结合起来
- 先在虚拟内存分段，然后再分页载入内存
![](http://i.imgur.com/FVVMmLR.png)
- 重定位（地址翻译）
- 两层地址翻译：段和页翻译
- 从用户的角度有段--内存硬件的角度看页
![](http://i.imgur.com/TrH5ze6.png)

- 一个实际的段，页式内存管理
![](http://i.imgur.com/Fztj2Z5.png)
- 如何载入内存
![](http://i.imgur.com/aWOl5XN.png)
- 5步实现
- 分配虚存，建段表
- GDT表是操作系统的段表，LDT每个进程的段表
![](http://i.imgur.com/lSa68wb.png)

- 父子进程都有自己的虚拟内存和物理内存，内存共用父进程的，然后进程就放在内存中
- 第5步内存用起来
![](http://i.imgur.com/OoEW3KW.png)

